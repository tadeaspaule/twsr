created: 20210106052443123
modified: 20210106052443123
module-type: macro
tags: 
title: $:/plugins/tadeaspaule/twsr/twsr-sidebar-open
type: application/javascript

(function() {
/*jslint node: true, browser: true */
/*global $tw: false */
"use strict";

exports.name = "twsr-sidebar-open";
exports.params = [];
exports.run = function() {

try {
// read decks and delays (and decrement if necessary) ----------------------------
var currentlyRevisingDeck = null
var currentlyRevising = null
var currentlyRevisingAt = -1
const configFilename = "$:/config/twsr-config"
const delaysFilename = "$:/config/twsr-delays"
const intervalsFilename = "$:/config/twsr-intervals"
var allTiddlers = $tw.wiki.allTitles()
var config = JSON.parse($tw.wiki.getTiddler(configFilename).fields.text)
const minMemoryStrength = config.minMemoryStrength || 1300 // used by Anki
var currentTimestamp = (new Date()).toISOString().split('T')[0]
var lastTimestamp = config.lastTimestamp || currentTimestamp
const diffTime = Math.abs(new Date(currentTimestamp) - new Date(lastTimestamp));
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); // to decrease delays
const logPrefix = "TWSR: "
console.log(logPrefix + diffDays + " days since last revision")
var delays = JSON.parse($tw.wiki.getTiddler(delaysFilename).fields.text)
var intervals = JSON.parse($tw.wiki.getTiddler(intervalsFilename).fields.text)
var tiddler2details = {}
var deck2Tiddlers = {}
var totalToRevise = 0
for (var i = 0; i < allTiddlers.length; i++) {
    var tiddler = $tw.wiki.getTiddler(allTiddlers[i])
    if (tiddler && tiddler.fields && tiddler.fields.tags && tiddler.fields.tags.includes("twsr")) {
        if (!delays[tiddler.fields.title]) delays[tiddler.fields.title] = 0
        else delays[tiddler.fields.title] = delays[tiddler.fields.title] - diffDays
        if (delays[tiddler.fields.title] && delays[tiddler.fields.title] > 0) continue // tiddler not yet due for revision
        tiddler2details[tiddler.fields.title] = tiddler.fields
        var tiddlerHasDeck = false
        for (var d = 0; d < config.decks.length; d++) {
            if (tiddler.fields.tags.includes(config.decks[d])) {
                tiddlerHasDeck = true
                if (deck2Tiddlers[config.decks[d]] == undefined) deck2Tiddlers[config.decks[d]] = []
                deck2Tiddlers[config.decks[d]].push(tiddler.fields.title)
            }
        }
        if (tiddlerHasDeck) totalToRevise += 1
    }
}
function saveJson (filename, tiddler) {
    $tw.wiki.addTiddler(new $tw.Tiddler({title: filename, text: JSON.stringify(tiddler,null,"\t"), type: "application/json"}))
}
config.lastTimestamp = currentTimestamp
saveJson(configFilename,config)
if (diffDays > 0) {
    // delays were changed, update timestamp and delays tiddler
    saveJson(delaysFilename,delays)
}
// setup UI and functionality ----------------------------------------------------
// add deck functionality
var addDeckInput = document.getElementById("twsr-add-deck").children[0];
addDeckInput.addEventListener("keyup", function(event) {
    // Number 13 is the "Enter" key on the keyboard
    if (event.keyCode === 13) {
        event.preventDefault();
        if (!config.decks.includes(addDeckInput.value)) {
            config.decks.push(addDeckInput.value)
            saveJson(configFilename,config)
            addDeckButton(addDeckInput.value)
            addDeckInput.value = ''
        }
    }
});
// revise anything
var revisingAnything = false
function reviseAnything() {
    revisingAnything = true
    var cardCount = 0
    config.decks.forEach(d => { cardCount += deck2Tiddlers[d] ? deck2Tiddlers[d].length : 0 })
    var i = Math.floor(Math.random() * cardCount)
    for (var d = 0; d < config.decks.length; d++) {
        if (!deck2Tiddlers[config.decks[d]]) continue
        for (var idx = 0; idx < deck2Tiddlers[config.decks[d]].length; idx++) {
            if (i == 0) {
                setCurrentlyRevising(config.decks[d], idx)
                return
            }
            i--
        }
    }
}
var reviseAnythingBtn = document.getElementById("twsr-revise-anything").children[0]
reviseAnythingBtn.addEventListener('click', reviseAnything)
// deck-specific revise
var twsrDecks = document.getElementById("twsr-decks")
function resetDeck (deckName) {
    var deckElem = document.getElementById("twsr-deck-" + deckName)
    deckElem.textContent = deckName + " (" + (deck2Tiddlers[deckName] || []).length + ")"
    if (!deck2Tiddlers[deckName] || deck2Tiddlers[deckName].length == 0) deck2Elem[currentlyRevisingDeck].style.display = "none"
}
var deck2Elem = {}
function addDeckButton (deckName) {
    var deckElem = document.getElementById("twsr-deck-" + deckName)
    if (!deckElem) {
        deckElem = document.createElement('button')
        deckElem.id = "twsr-deck-" + deckName
        deckElem.className = 'tc-tag-label tc-tag-list-item tc-btn-invisible'
        deckElem.addEventListener('click', function () {
            if (!deck2Tiddlers[deckName] || deck2Tiddlers[deckName].length == 0) return
            revisingAnything = false
            setCurrentlyRevising(deckName, Math.floor(Math.random()*deck2Tiddlers[deckName].length))
        })
        twsrDecks.appendChild(deckElem)
    }
    deckElem.textContent = deckName + " (" + (deck2Tiddlers[deckName] || []).length + ")"
    deck2Elem[deckName] = deckElem
}
config.decks.forEach(d => {
    if (deck2Tiddlers[d]) addDeckButton(d)
})
var numToReviseElem = document.getElementById("twsr-number-to-revise")
numToReviseElem.textContent = `${totalToRevise} cards to revise today`
var reviseOuterElem = document.getElementById("twsr-revise-outer")
if (totalToRevise == 0) {
    reviseOuterElem.style.display = "none"
    return
}
var revisingNameText = document.getElementById("twsr-revising-name")
var revisingShowLink = document.getElementById("twsr-revising-show")
revisingShowLink.addEventListener('click', showResultButtons)
var results = ['again','hard','good','easy']
var resultButtons = document.getElementById("twsr-res-btns")
function finishOneRevision(newDelay, newMemoryStrength) {
    // update delays, config, intervals DataTiddlers
    delays[currentlyRevising] = newDelay
    config.memoryStrength = newMemoryStrength
    intervals[currentlyRevising] = newDelay
    saveJson(configFilename,config)
    saveJson(delaysFilename,delays)
    saveJson(intervalsFilename,intervals)
    totalToRevise--
    numToReviseElem.textContent = `${totalToRevise} cards to revise today`
    // update deck UI and data
    console.log(logPrefix + "new delay for \"" + currentlyRevising +"\" is " + newDelay)
    if (newDelay > 0) {
        tiddler2details[currentlyRevising].tags.forEach(t => {
            if (deck2Tiddlers[t]) {
                for (var i = 0; i < deck2Tiddlers[t].length; i++) {
                    if (deck2Tiddlers[t][i] == currentlyRevising) {
                        console.log(logPrefix + "Removing revised card from deck " + t)
                        deck2Tiddlers[t].splice(i,1)
                        resetDeck(t)
                        break
                    }
                }
            }
        })
    }
    if (totalToRevise == 0) {
        reviseOuterElem.style.display = "none"
        return
    }
    // potentially set a different deck
    if (revisingAnything) {
        reviseAnything()
        return
    }
    if (deck2Tiddlers[currentlyRevisingDeck].length > 0) {
        // show new thing to revise ...
        setCurrentlyRevising(currentlyRevisingDeck, Math.floor(Math.random()*deck2Tiddlers[currentlyRevisingDeck].length))
    }
    else {
        // ... or reset to default
        revisingNameText.textContent = 'Revising: '
        revisingShowLink.textContent = ''
    }
}
for (var i = 0; i < 4; i++) {
    const idx = i
    var resBtn = document.getElementById("twsr-res-" + results[idx])
    resBtn.addEventListener('click', function () {
        resultButtonClicked(idx)
        resultButtons.style.display = 'none'
    })
}
// vars for results (setting new intervals and memoryStrength)
var m0 = config.failMultiplier || 0, m = config.multiplier || 1, m4 = config.easyMultiplier || 1.3
var newDelays = [], newFs = []
function resultButtonClicked (index) {
    // using Anki algorithms found described here: https://gist.github.com/fasiha/31ce46c36371ff57fdbc1254af424174
    finishOneRevision(newDelays[index],newFs[index])
}
resultButtons.style.display = 'none'
function setCurrentlyRevising(deckName,index) {
    var value = deck2Tiddlers[deckName][index]
    if (!value) return
    console.log(logPrefix + "Currently revising set to " + value)
    currentlyRevising = value
    currentlyRevisingDeck = deckName
    currentlyRevisingAt = index
    var prompt = value
    if (tiddler2details[currentlyRevising].prompt) {
        prompt = tiddler2details[currentlyRevising].prompt
        // check if Cloze prompt
        var clozeParts = prompt.match(/c\[[^\]]+\]/g)
        if (clozeParts && clozeParts.length > 0) {
            var i = Math.floor(Math.random() * clozeParts.length)
            // hide one of the parts
            prompt = prompt.replace(clozeParts[i], "____")
            // reveal the rest
            for (var idx = 0; idx < clozeParts.length; idx++) {
                prompt = prompt.replace(clozeParts[idx], clozeParts[idx].slice(2,clozeParts[idx].length-1))
            }
        }
    }
    revisingNameText.textContent = 'Revising: ' + prompt
    revisingShowLink.href = '#'+value // TODO instead use some $tw navigation functionality?
    // revisingShowLink.addEventListener('click', function() { everything I try still ends up with # remaining
    //     setTimeout(() => { // not a big deal but annoying
    //         window.history.pushState({},document.title,'/')
    //     },20);
    // })
    revisingShowLink.textContent = 'show'
    resultButtons.style.display = 'none'
    // update look & values for result buttons
    var f = Math.max(config.memoryStrength || 0, minMemoryStrength)
    var i = intervals[currentlyRevising] || 0, d = isNaN(delays[currentlyRevising]) ? 0 : Math.abs(delays[currentlyRevising]),
        i1 = m0 * i,
        i2 = Math.max(i + 1, (i + d/4) * 1.2 * m),
        i3 = Math.max(i2 + 1, (i + d/2) * (f / 1000) * m),
        i4 = Math.max(i3 + 1, (i + d) * (f / 1000) * m * m4)
    newDelays = [i1,i2,i3,i4]
    newFs = [
        Math.max(minMemoryStrength, f - 200),
        Math.max(minMemoryStrength, f - 150),
        f,
        Math.max(minMemoryStrength, f + 150)
    ]
    for (var idx = 0; idx < 4; idx++) {
        resultButtons.children[idx].innerHTML = results[idx] + "<br/>(" + Math.ceil(newDelays[idx]) + "d)"
    }
}
function showResultButtons () {
    resultButtons.style.display = 'flex'
}

} catch (err) {
    console.error(err.stack)
    return "(ERROR: " + err.message + ") ";
}};

})();
